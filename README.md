# ismcsolver
[![Build Status](https://travis-ci.org/sfranzen/ismcsolver.svg?branch=master)](https://travis-ci.org/sfranzen/ismcsolver)
[![codecov](https://codecov.io/gh/sfranzen/ismcsolver/branch/master/graph/badge.svg)](https://codecov.io/gh/sfranzen/ismcsolver)

ismcsolver is a header-only C++11 library providing [information set Monte Carlo tree search][ISMCTS] (ISMCTS) algorithms. Monte Carlo tree search is a (game) AI decision making algorithm noted for its applicability to many different games of perfect information, requiring no domain-specific knowledge and only little information about a game's state. ISMCTS is an elegant extension of this technique to imperfect information games, where not all information is visible to all players, possibly combined with factors of randomness.

The code began its life inside a Qt game I wrote to explore game AI, eventually extracted to make testing easier and ported to standard C++ to make it portable to any future projects. It provides class templates to allow using the algorithm with a generic type of game using a generic type of move.

[ISMCTS]: https://pure.york.ac.uk/portal/files/13014166/CowlingPowleyWhitehouse2012.pdf

## Installation
Due to the nature of header-only libraries, no installation is technically necessary. You can use the headers in three ways:
* Using any build system:
    Simply copy the `include` folder to your project and configure your own build. In this case, you must ensure that build targets using a solver class are linked to an implementation of `<thread>`, e.g. by specifying `-lpthread`;
* Using CMake:
    * Clone this repository into a subdirectory of your project, e.g. ext/ismcsolver, and add it to your main CMakeLists.txt:
        ```cmake
        add_subdirectory(ext/ismcsolver)
        ```
    * Install the headers to a system location and use `find_package()`:
        ```cmake
        find_package(ismcsolver REQUIRED)
        ```
    In either case you can then link your targets as follows, which will automatically propagate compilation and linking options:
    ```cmake
    add_executable(foo foo.cpp)
    target_link_libraries(foo ismcsolver)
    ```

## Usage
First and foremost, your game (or engine) class should implement the abstract interface [`ISMCTS::Game<Move>`][game], replacing the template parameter `Move` with the data type (or class) representing a player's move. The library provides two solver class templates, [`ISMCTS::SOSolver<Move>`][SO] and [`ISMCTS::MOSolver<Move>`][MO]. Their differences are explained [below](#features), but they should be instantiated with the same `Move` type to obtain an object that can select moves for the AI player(s), e.g.
```cpp
#include <ismcts/sosolver.h>
// ...
void MyGame::doAIMove()
{
    ISMCTS::SOSolver<MyMove> solver;
    this->doMove(solver(*this));
}
```
Documentation of all library templates, generated by doxygen, is hosted at this repository and can be viewed at its [GitHub Page][docs].

A simple card game (Knockout Whist) is included [here][whist], based on the example Python code available [here][py]. Its main purpose is to test the compilation and functioning of the library code, but it also serves as an example implementation of the `ISMCTS::Game` interface.

[game]: include/ismcts/game.h
[SO]: include/ismcts/sosolver.h
[MO]: include/ismcts/mosolver.h
[docs]: https://sfranzen.github.io/ismcsolver/
[whist]: test/common/knockoutwhist.cpp
[py]: https://gist.github.com/kjlubick/8ea239ede6a026a61f4d

## Type requirements
The type `Move` specified for the game and sequential solver templates must be a *[TrivialType]* that is *[EqualityComparable]*. Solvers with root parallelisation use a `std::map` to evaluate visit counts, so the `Move` must additionally be *[LessThanComparable]*.

[TrivialType]: https://en.cppreference.com/w/cpp/named_req/TrivialType
[EqualityComparable]: https://en.cppreference.com/w/cpp/named_req/EqualityComparable
[LessThanComparable]: https://en.cppreference.com/w/cpp/named_req/LessThanComparable

## About random numbers
Game implementations will need a source of random numbers. Because `std::rand` does not guarantee a good quality sequence and may not be thread safe, modern code should use the `<random>` header. The objects representing generator engines are large, so the following is a good way of providing one to your class:
```cpp
#include <random>
// definition as member of MyGame, could be const or static
std::mt19937 &MyGame::prng()
{
    static thread_local std::mt19937 prng {std::random_device{}()};
    return prng;
}
```
This sets up one pseudorandom Mersenne Twister engine per thread, seeded with random numbers from a non-deterministic source if available. It can be used for shuffling, e.g. `std::shuffle(cards.begin(), cards.end(), prng());`. Single numbers on (closed) intervals should be generated using one of the available distributions:
```cpp
std::uniform_int_distribution<> singleDie {1, 6};
auto result = singleDie(prng());
```

## Features
The basic algorithm can be applied, modified and executed in different ways. This section lists what is currently implemented.

### SO- and MO-ISMCTS
These are two variants of the algorithm, respectively Single-Observer and Multiple-Observer. The former is implemented in `ISMCTS::SOSolver` and, as its name implies, observes the game from only one perspective: that of the player conducting the search. It only builds a tree for that player and treats all opponent moves as fully observable. While that is indeed the case in many games, some additionally feature actions that are hidden from the other players. MO-ISMCTS, implemented in `ISMCTS::MOSolver`, is intended for such games; it builds a tree for each player to model the presence of this extra hidden information.

### Multithreading
Several approaches to parallel tree searching exist, see e.g. [Parallelization of Information Set Monte Carlo Tree Search][par] by Nick Sephton and the authors of ISMCTS. At present, this library provides the most straightforward method of root parallelisation. It distributes the iterations over the system threads, with each thread searching a separate tree. The statistics from the root of each tree are then combined to find the overall best move. This method is very fast as it avoids synchronisation issues and the additional work is limited to a single layer of nodes in each tree.

This is implemented using the `std::thread` class and can be used by providing the optional second `ExecutionPolicy` parameter to either class template. Template specialisations are provided for two policies, defined in [execution.h]: `ISMCTS::Sequential` (the default) and `ISMCTS::RootParallel`. For example, the following instantiates a parallel `MOSolver` for a two player game where `int` represents a move:
```cpp
ISMCTS::MOSolver<int, ISMCTS::RootParallel> solver {2};
```
[execution.h]: include/ismcts/execution.h
[par]: https://www-users.cs.york.ac.uk/~nsephton/papers/wcci2014-ismcts-parallelization.pdf

### Time-limited execution
Each solver type has two constructors; one that sets the search operator to iterate a fixed number of times, the other instead letting it search for a fixed length of time (a `std::chrono::duration<double>`). Both the mode of operation and the length of the search can be changed after instantiation. A duration can be created using any of the convenience typedefs in [`std::chrono`][chrono], e.g.:

```cpp
using namespace std::chrono;
ISMCTS::SOSolver<int> solver {milliseconds(5)};
```
or even shorter with literal operators, since C++14:
```cpp
using namespace std::chrono_literals;
ISMCTS::SOSolver<int> solver {5ms};
```
[chrono]: https://en.cppreference.com/w/cpp/header/chrono

## License
This project is licensed under the MIT License, see the [LICENSE](LICENSE) file for details.
