<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ismcsolver: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ismcsolver
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ismcsolver Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>ismcsolver</h1>
<p>ismcsolver provides a C++ implementation of information set Monte Carlo tree search (ISMCTS) algorithms. Monte Carlo tree search is a (game) AI decision making algorithm noted for its applicability to many different games of perfect information, requiring no domain-specific knowledge and only little information about a game's state. ISMCTS is an elegant extension of this technique to imperfect information games, where not all information is visible to all players, possibly combined with factors of randomness.</p>
<p>This implementation uses C++ class templates to apply the algorithm to a generic type of game using a generic type of move. At the moment it adheres to the C++11 standard.</p>
<h2>Usage</h2>
<p>You can either install the header files or just copy them into your project sources. Your game (or engine) class should implement the abstract interface <code><a class="el" href="classISMCTS_1_1Game.html">ISMCTS::Game</a>&lt;Move&gt;</code>, replacing the template parameter <code>Move</code> with the data type (or class) representing a player's move. The library provides two solver class templates, <code><a class="el" href="classISMCTS_1_1SOSolver.html">ISMCTS::SOSolver</a>&lt;Move&gt;</code> and <code><a class="el" href="classISMCTS_1_1MOSolver.html">ISMCTS::MOSolver</a>&lt;Move&gt;</code>. Their differences are explained below, but they should be instantiated with the same <code>Move</code> type to obtain an object that can select moves for the AI player(s), e.g. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ismcts/sosolver.h&gt;</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keywordtype">void</span> MyGame::doAIMove()</div><div class="line">{</div><div class="line">    <a class="code" href="classISMCTS_1_1SOSolver.html">ISMCTS::SOSolver&lt;MyMove&gt;</a> solver;</div><div class="line">    this-&gt;doMove(solver(*<span class="keyword">this</span>));</div><div class="line">}</div></div><!-- fragment --><p> A simple card game (Knockout Whist) is included [here](test), based on the example Python implementation available <a href="https://gist.github.com/kjlubick/8ea239ede6a026a61f4d">here</a>. Its main purpose is to test the compilation and functioning of the library code, but it also serves as an example implementation of the <code><a class="el" href="classISMCTS_1_1Game.html">ISMCTS::Game</a>&lt;Move&gt;</code> interface.</p>
<h2>The algorithm</h2>
<p>The following is only a short summary of how ISMCTS works. For the full technical details, see the paper <a href="https://pure.york.ac.uk/portal/files/13014166/CowlingPowleyWhitehouse2012.pdf">Information Set Monte Carlo Tree Search</a> by Peter I. Cowling, Edward J. Powley and Daniel Whitehouse.</p>
<p>Most importantly, the "information set" part of ISMCTS refers to the set of all possible game states consistent with a given player's observation of a game so far. In a typical card game, for example, it contains the permutations of the cards possibly held by the player's opponents, given the game's rules and the sequence of cards already played. The algorithm works by taking random samples from this set, called determinisations, to gradually build an information tree using regular Monte Carlo searches:</p>
<p>0. <em>Determinise</em>;</p><ol type="1">
<li><em>Select:</em> Using a selection algorithm, choose a sequence of moves from the root of the tree until either a node with unexplored moves is reached or the game ends;</li>
<li><em>Expand:</em> If there are unexplored moves, choose one at random and create a new node for it;</li>
<li><em>Simulate:</em> Continue applying random moves from this state until the game ends;</li>
<li><em>Backpropagate:</em> Update the tree by incrementing the visit counter and adding the score for the given player to this final node and each of its parents.</li>
</ol>
<p>Successive iterations of these steps result in sequences of moves that are initially random, but increasingly become shaped by the availability of moves in different determinisations as well as the selection algorithm. Different selection algorithms are possible, but this library for now uses the UCB (Upper Confidence Bound) algorithm also used by the authors of ISMCTS.</p>
<p>The total number of iterations performed per search may be dictated, for example, by the available computational budget or a desired player strength. Upon finishing the search, the move corresponding to the most visited child node of the root of the resulting tree is selected as the most promising move.</p>
<h2>Features</h2>
<p>The basic algorithm can be applied, modified and executed in different ways. This section lists what is currently implemented.</p>
<h3>SO- and MO-ISMCTS</h3>
<p>These are two variants of the algorithm, respectively Single-Observer and Multiple-Observer. The former is implemented in <code><a class="el" href="classISMCTS_1_1SOSolver.html">ISMCTS::SOSolver</a></code> and, as its name implies, observes the game from only one perspective: that of the player conducting the search. It only builds a tree for that player and treats all opponent moves as fully observable. While that is indeed the case in many games, some additionally feature actions that are hidden from the other players. MO-ISMCTS, implemented in <code><a class="el" href="classISMCTS_1_1MOSolver.html">ISMCTS::MOSolver</a></code>, is intended for such games; it builds a tree for each player to model the presence of this extra hidden information.</p>
<h3>Multithreading</h3>
<p>Several approaches to parallel tree searching exist, see e.g. <a href="https://www-users.cs.york.ac.uk/~nsephton/papers/wcci2014-ismcts-parallelization.pdf">Parallelization of Information Set Monte Carlo Tree Search</a> by Nick Sephton and the authors of ISMCTS. At present, this library provides the most straightforward method of root parallelisation. It distributes the iterations over the system threads, with each thread searching a separate tree. The statistics from the root of each tree are then combined to find the overall best move. This method is very fast as it avoids synchronisation issues and the additional work is limited to a single layer of nodes in each tree.</p>
<p>This is implemented using the <code>std::thread</code> class and can be used by providing the optional second <code>ExecutionPolicy</code> parameter to either class template. Template specialisations are provided for two policies, defined in <a href="include/execution.h">execution.h</a>: <code><a class="el" href="classISMCTS_1_1Sequential.html" title="All iterations are executed by a single thread on a single tree.">ISMCTS::Sequential</a></code> (the default) and <code><a class="el" href="classISMCTS_1_1RootParallel.html">ISMCTS::RootParallel</a></code>. For example, the following instantiates a parallel <code>MOSolver</code> for a two player game where <code>int</code> represents a move: </p><div class="fragment"><div class="line"><a class="code" href="classISMCTS_1_1MOSolver.html">ISMCTS::MOSolver&lt;int, ISMCTS::RootParallel&gt;</a> solver {2};</div></div><!-- fragment --><h3>Time-limited execution</h3>
<p>Each solver type has two constructors; one that sets the search operator to iterate a fixed number of times, the other a <code>std::chrono::duration&lt;double&gt;</code> instead letting it search for the given length of time. Both the mode of operation and the length of the search can be changed after instantiation. A duration can be created using any of the convenience typedefs in <a href="https://en.cppreference.com/w/cpp/header/chrono"><code>std::chrono</code></a>, e.g.:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono;</div><div class="line"><a class="code" href="classISMCTS_1_1SOSolver.html">ISMCTS::SOSolver&lt;int&gt;</a> solver {milliseconds(5)};</div></div><!-- fragment --><p> or even shorter with literal operators, since C++14: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span>std::chrono_literals;</div><div class="line"><a class="code" href="classISMCTS_1_1SOSolver.html">ISMCTS::SOSolver&lt;int&gt;</a> solver {5ms};</div></div><!-- fragment --><h2>License</h2>
<p>This project is licensed under the MIT License, see the [LICENSE](LICENSE) file for details. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
